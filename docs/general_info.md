# Application

## Description

```
Text-to-Chain is an SMS-based DeFi platform that lets users create wallets, hold and send tokens, swap, bridge cross-chain, and cash out to stablecoins using only text messages. The goal is to bring real on-chain DeFi to the 2.5 billion people who use feature phones: no smartphone, no app store, no browser, no internet, and often no bank account.

**The problem.** For many people, joining the global economy is not about convenience but access. Large populations have no banks, limited or no internet, no app stores, and no digital wallets. Infrastructure may never have been built, may have been destroyed, or may simply be out of reach. The result is that people who could benefit from digital finance are excluded. The challenge is inclusion: how to include unbanked users who have no internet or smartphone. Today there are 2.5 billion feature-phone users, zero DeFi accessible to them over their primary device, and no existing SMS-native DeFi platform.

**The solution.** Instead of requiring better phones or internet, Text-to-Chain asks: what if Web3 worked over SMS? The user’s only interface is SMS. They send a text to a phone number; the system parses commands, looks up the user by phone number, and executes on-chain or off-chain actions on their behalf. From the user’s perspective: one SMS to create a wallet, one to check balance, one to send money, swap tokens, or cash out. Under the hood, value lives in real wallets on public chains (Ethereum Sepolia, Arc Testnet, and others via Li.Fi); swaps and bridges use Uniswap, Circle CCTP, and Li.Fi. The SMS layer is only the interface; it does not act as a ledger.

**What users can do.** Onboarding is a single message: `JOIN` or `JOIN alice`. That creates an on-chain EOA and, if a name is given, registers an ENS subdomain (e.g. `alice.ttcip.eth`) so others can send to a human-readable name. The user can then: `BALANCE` (TXTC and ETH), `DEPOSIT` (get wallet address), `REDEEM <code>` (voucher → TXTC), `SEND <amt> TXTC TO <name or address>` (batched off-chain via Yellow, then settled on-chain), `SWAP <amt> TXTC` (TXTC → ETH via Uniswap V3), `CASHOUT <amt> TXTC` (TXTC → USDC on Arc via CCTP), and `BRIDGE` (cross-chain via Li.Fi). Optional: contacts (`SAVE`/`CONTACTS`), `PIN` for extra protection, `CHAIN` to switch chain context. There are 13+ commands; all are triggered and confirmed via SMS.

**Trust and security.** The system is intentionally server-centric today: one wallet per phone, key material stored and used on the server so the user never sees seed phrases or signs raw transactions. The server (SMS Request Handler plus backends) is the trusted component for execution and key handling. User funds, however, sit in their own on-chain addresses; settlement is on public chains. The architecture is designed so that the key-handling path can later be moved into a TEE or secure enclave, reducing trust to an attested component rather than the whole server. Security measures include: no private keys in frontends, secrets in env/secrets manager, owner-only contract functions (e.g. `burnFromAny`, `mint`) restricted to the backend, optional PIN, and ReentrancyGuard on state-changing contract functions.

**Scale and impact.** The project targets the 2.5B feature-phone users who today have no SMS-native way to access DeFi. It demonstrates that full DeFi (wallets, transfers, swaps, cross-chain bridge, stablecoin cashout) can be delivered through the only universal interface many of them have: SMS.
```

---

## How it's made

```
**Stack and entrypoint.** The only user-facing entrypoint is SMS. Twilio receives SMS and sends HTTP POSTs to our webhook. That webhook is served by a **Rust + Axum** service (SMS Request Handler, port 8080): it validates the Twilio request, parses the message body into a command, resolves the user by phone number from **PostgreSQL** (users, vouchers, contacts, encrypted key material), and routes to the appropriate backend. All responses and notifications go back out via Twilio as SMS. We use **Caddy** with **sslip.io** for automatic HTTPS in development and on a single host (no manual certs); production can use the same or a different reverse proxy.

**Command routing and backends.** The handler does not execute chain logic itself. For read-only operations (e.g. `BALANCE`, `DEPOSIT`), it calls the **Backend API** (TypeScript/Express, port 3000), which uses **ethers.js v6** to read on-chain state and returns formatted data; the handler turns that into an SMS. For `SEND`, the handler enqueues the transfer in the **Yellow Network** service (port 8083), which batches transfers and uses the **Nitrolite** SDK and state channels to settle off-chain, then periodically settles on-chain so TXTC is minted to recipients. For `SWAP`, `REDEEM`, ENS registration, and `BRIDGE`, the handler calls the Backend API, which talks to Sepolia (and, for BRIDGE, Li.Fi). For `CASHOUT`, the handler calls the **Arc service** (port 8084), which performs TXTC → WETH → USDC on Sepolia and then uses **Circle CCTP V2** to bridge USDC to Arc and credit the user’s **Circle Developer-Controlled Wallet**. So: one Rust service as the single SMS entrypoint, three main execution backends (Backend API, Yellow, Arc), plus an airtime service (port 8082) for airtime-to-TXTC; all backends share the same chain RPC (e.g. Alchemy) and the backend wallet where needed.

**Smart contracts.** On **Ethereum Sepolia** we deploy: **TXTC** (ERC20 with minter roles and `burnFromAny`), **VoucherManager** (shop staking, voucher generation and redemption), **EntryPointV3** (orchestration hub: swap, redeem, authorized backend only), and **UniswapV3PoolManager** plus the **Uniswap V3** TXTC/WETH pool (0.3% fee). Contracts are written in **Solidity** and tested with **Foundry** (102 tests); core contracts have high line/statement/branch coverage. EntryPointV3 is allowlisted so only our backend can call sensitive operations; ReentrancyGuard is used on state-changing functions.

**Partner technologies and how they’re used.**

- **Yellow Network / Nitrolite** — SEND does not hit the chain per transfer. Transfers are queued, batched in a ~3-minute window, and executed via Nitrolite state channels; settlement mints TXTC to recipients on Sepolia. This cuts gas cost (we see up to ~67% reduction in gas-related cost) and makes small transfers viable; for the user it feels instant.
- **Uniswap V3** — SWAP uses a dedicated TXTC/WETH pool (0.3%). CASHOUT uses that pool plus a WETH/USDC pool (0.05%) on Sepolia. We use the SwapRouter and exactInputSingle for deterministic execution.
- **Circle CCTP V2** — CASHOUT converts TXTC to USDC on Sepolia, then uses CCTP `depositForBurn` (Sepolia → Arc, domain 0 → 26). Circle’s attestation (e.g. Iris API, Fast Transfer ~20s) is consumed on Arc to mint USDC. Each user has a **Circle Developer-Controlled Wallet** keyed by phone; the Arc service holds the mapping and can credit USDC to that wallet so the user receives stablecoin on Arc without ever touching a dApp.
- **ENS** — We run a subdomain registrar for `*.ttcip.eth`. `JOIN alice` triggers a commit-reveal (or equivalent) registration so the user’s address resolves to `alice.ttcip.eth`; SEND accepts ENS names so users can type names instead of raw addresses in SMS.

**How the pieces fit together.** Inbound SMS hits the Rust handler over HTTPS. The handler authenticates (Twilio signature), parses the command, loads or creates the user (phone → wallet, encrypted key, ENS name) from Postgres, and dispatches: read-only → Backend API; SEND → Yellow (enqueue, async status later); SWAP/REDEEM/ENS/BRIDGE → Backend API; CASHOUT → Arc service. The Backend API and Arc service use the same backend EOA for chain submission where needed; for user-signed flows (e.g. certain bridge steps), the server uses the stored key material for that phone to sign. Outbound SMS (balance reply, “Sent X TXTC to Y”, “Cashout complete”, etc.) is sent by the handler or backends via Twilio. So: one request path (SMS → Handler → DB + one of the backends → chain or Yellow/Arc), one response path (backend/handler → Twilio → SMS).


All of this is packaged so that `docker compose up -d --build` brings up the handler, Backend API, Yellow service, Arc service, airtime service, Postgres, and Caddy; the only external dependencies are Twilio, RPC (e.g. Alchemy), and Circle/Arc APIs, configured via env vars.
```
